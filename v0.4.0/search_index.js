var documenterSearchIndex = {"docs":
[{"location":"explanation/#MPSGE.jl-How,-why,-and-what","page":"Explanation and Discussion","title":"MPSGE.jl How, why, and what","text":"","category":"section"},{"location":"explanation/#Overview","page":"Explanation and Discussion","title":"Overview","text":"","category":"section"},{"location":"explanation/#What-is-Computable-General-Equilibriumm","page":"Explanation and Discussion","title":"What is Computable General Equilibriumm","text":"","category":"section"},{"location":"explanation/#What-is-MPSGE","page":"Explanation and Discussion","title":"What is MPSGE","text":"","category":"section"},{"location":"explanation/#The-model","page":"Explanation and Discussion","title":"The model","text":"","category":"section"},{"location":"explanation/#Basic-components-of-every-MPSGE-model","page":"Explanation and Discussion","title":"Basic components of every MPSGE model","text":"","category":"section"},{"location":"explanation/#Commodities","page":"Explanation and Discussion","title":"Commodities","text":"","category":"section"},{"location":"explanation/#Sectors","page":"Explanation and Discussion","title":"Sectors","text":"","category":"section"},{"location":"explanation/#Productions","page":"Explanation and Discussion","title":"Productions","text":"","category":"section"},{"location":"explanation/#Outputs","page":"Explanation and Discussion","title":"Outputs","text":"","category":"section"},{"location":"explanation/#Inputs","page":"Explanation and Discussion","title":"Inputs","text":"","category":"section"},{"location":"explanation/#Demand-Functions","page":"Explanation and Discussion","title":"Demand Functions","text":"","category":"section"},{"location":"explanation/#Demands","page":"Explanation and Discussion","title":"Demands","text":"","category":"section"},{"location":"explanation/#Endowments","page":"Explanation and Discussion","title":"Endowments","text":"","category":"section"},{"location":"explanation/#Additional-components","page":"Explanation and Discussion","title":"Additional components","text":"","category":"section"},{"location":"explanation/#Parameters","page":"Explanation and Discussion","title":"Parameters","text":"","category":"section"},{"location":"explanation/#Taxes","page":"Explanation and Discussion","title":"Taxes","text":"","category":"section"},{"location":"explanation/#Nonunitary-prices","page":"Explanation and Discussion","title":"Nonunitary prices","text":"","category":"section"},{"location":"explanation/#Auxiliary-Variables/Constraints","page":"Explanation and Discussion","title":"Auxiliary Variables/Constraints","text":"","category":"section"},{"location":"howtoguides/#How-tos","page":"How-to Guides","title":"How-tos","text":"","category":"section"},{"location":"howtoguides/#Add-data","page":"How-to Guides","title":"Add data","text":"","category":"section"},{"location":"howtoguides/","page":"How-to Guides","title":"How-to Guides","text":"Use DenseAxisArrays for any data that's indexed, including a table. Use 'missing' to hold any spaces (see example 5). For a simple scalar model, it's straightforward just to use the values when defining the quantities in Outputs and Inputs, but here's a single index DenseAxisArray for illustration.","category":"page"},{"location":"howtoguides/","page":"How-to Guides","title":"How-to Guides","text":"using MPSGE.JuMP.Containers\nsampleindex = [:x]\ndata = DenseAxisArray(Float64[100], sampleindex)","category":"page"},{"location":"reference/#Reference-Guide","page":"Reference","title":"Reference Guide","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Model\nadd!\nParameter\nSector\nInput\nOutput\nset_value\nset_fixed!\nsolve!","category":"page"},{"location":"reference/#MPSGE.Model","page":"Reference","title":"MPSGE.Model","text":"Model()     The struct that stores all the elements of the model.\n\nExample\n\njulia> foo = Model()\n\n\n\n\n\n","category":"type"},{"location":"reference/#MPSGE.add!","page":"Reference","title":"MPSGE.add!","text":"add!(m,bar)\nFunction that adds an element to the model with a name assignment\nm::Model is always the first Argument\n\n# Options\nParameter::ScalarParameter, ::IndexedParameter\nCommodity::ScalarCommodity, ::IndexedCommodity\nSector::ScalarSector,       ::IndexedSector\nConsumer::ScalarConsumer,   ::IndexedConsumer\nAux::ScalarAux,             ::IndexedAux\n\nExample\n\njulia> S = add!(m, Sector())\n\nProduction::Production\nDemand::DemandFunction\nAuxConstraint::AuxConstraint\n\nExample\n\njulia> add!(m, Production()) \n\n\n\n\n\n","category":"function"},{"location":"reference/#MPSGE.Parameter","page":"Reference","title":"MPSGE.Parameter","text":"Parameter(:symbol; indices, value::Float64=1., string)\nStruct that holds the name, indices if IndexedParameter, value, and optional description of a parameter within the model.\n\nOptions\n\nParameter::ScalarParameter, IndexedParameter\n\nExample\n\njulia> P = add!(Parameter(model, :P, value=1., description=\"Elasticity\"))\njulia> sectors = [:s1, :s2]\njulia> P = add!(Parameter(model, :P, indices=(,sectors), value=1., description=\"Elasticity parameters for X Sector \"))\n\n\n\n\n\n","category":"type"},{"location":"reference/#MPSGE.Sector","page":"Reference","title":"MPSGE.Sector","text":"Sector(:symbol; indices, value::Float64=1., string)\nStruct that holds the name, (indices if IndexedSector), value, and optional description of a sector within the model.\n\nOptions\n\nSector::ScalarSector, IndexedSector\n\nExample\n\njulia> S = add!(Sector(model, :S, value=1., description=\"Sector S\"))\njulia> sectors = [:s1, :s2]\njulia> P = add!(Sector(model, :S, indices=(,sectors), value=1., description=\"S[:s1] and S[:s2] Sectors\"))\n\n\n\n\n\n","category":"type"},{"location":"reference/#MPSGE.Input","page":"Reference","title":"MPSGE.Input","text":"Input(inputname::Symbol, value::Float64; taxes=taxes::Vector{Tax}, price=price::Union{Float64,Expr}=1.)     The struct that stores all the elements of an Input.\n\nOptions\n\n    Taxes and price are optional, keyword must be used.\n\nExample\n\njulia> Input(:PL, 50, taxes=[Tax(1., RA)], price=1.2)\n\n\n\n\n\n","category":"type"},{"location":"reference/#MPSGE.Output","page":"Reference","title":"MPSGE.Output","text":"Output(outputname::Symbol, value::Float64; taxes=taxes::Vector{Tax}, price=price::Union{Float64,Expr}=1.)     The struct that stores all the elements of an Input.\n\nOptions\n\n    Taxes and price are optional, keyword must be used.\n\nExample\n\njulia> Output(:PU, 50, taxes=[Tax(0.1, CONS)], price=.9)\n\n\n\n\n\n","category":"type"},{"location":"reference/#JuMP.set_value","page":"Reference","title":"JuMP.set_value","text":"set_value(P, value::Float64)\nFunction that allows users to set a specific value for a variable, updating the benchmark field.\n\nOptions\n\nParameter::ScalarParameter, ::IndexedParameter\nCommodity::ScalarCommodity, ::IndexedCommodity\nSector::ScalarSector,       ::IndexedSector\nConsumer::ScalarConsumer,   ::IndexedConsumer\nAux::ScalarAux,             ::IndexedAux\n\nExample\n\njulia> set_value(var, 1.3)\n\n\n\n\n\n","category":"function"},{"location":"reference/#MPSGE.set_fixed!","page":"Reference","title":"MPSGE.set_fixed!","text":"set_fixed!(P, true::Boolean)\nFunction that allows users to fix a value for a variable, the benchmark, the value from set_value, or the previous value.\n\nOptions\n\nParameter::ScalarParameter, ::IndexedParameter\nCommodity::ScalarCommodity, ::IndexedCommodity\nSector::ScalarSector,       ::IndexedSector\nConsumer::ScalarConsumer,   ::IndexedConsumer\nAux::ScalarAux,             ::IndexedAux\n\nExample\n\njulia> set_fixed!(var, false)\n\n\n\n\n\n","category":"function"},{"location":"reference/#MPSGE.solve!","page":"Reference","title":"MPSGE.solve!","text":"solve!(m::Model; solver=solvername, keywords)\nFunction to solve the model. Triggers the build if the model hasn't been built yet.\n\nArgumenents\n\nSee PATHSolver and the linked PATH webpage for full list of argument Options\n\nExample\n\njulia> solve!(m, cumulative_iteration_limit=0)\n\n\n\n\n\n","category":"function"},{"location":"#MPSGE.jl","page":"Home","title":"MPSGE.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MPSGE.jl is a Julia evolution of the GAMS subsystem MPSGE. The Documentation for the GAMS MPSGE should be useful to reference, especially for background, theory, and for some understanding of the included features, especially while the MPSGE.jl documentation is still being written.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Tutorial includes links to install Julia and the package, as well as the suggestion that as the tagged version of the package may not always be up-to-date as things are still in active development, adding MPSGE#main instead will get you the latest working development version of the package.","category":"page"},{"location":"#","page":"Home","title":"","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The documentation here will probably grow in fits and starts. Please give us feedback as we go, and let us know what breaks, and what would be especially helpful.","category":"page"},{"location":"tutorial/#Tutorial-1:-basics","page":"Tutorial","title":"Tutorial 1: basics","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Note\nThis tutorial assumes you have installed Julia, for example from here, or here, and\ninstalled the MPSGE package, \nhave some kind of source-code editor/Integrated Development Environment (IDE), for example the free VS Code, with the julia Language Support extension also recommended, or otherwise are able to run Julia code, \nhave a basic understanding of Julia syntax, and\nhave a general understanding of CGE and the MPSGE structure.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This first tutorial follows the first section in example 1 from our code repository, which is an edited translation of the simple 2x2 example model from the GAMS MPSGE documentation.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can run the commands line-by-line wherever you run Julia code, or all together as a .jl script, either transcribing, or copying and pasting from here, or example 1.  ","category":"page"},{"location":"tutorial/#Activate-the-package-with","page":"Tutorial","title":"Activate the package with","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia>using MPSGE","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Start by naming the model using any Julia-legal variable name, without spaces etc. The Julia style guide suggests lower case for variable names.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"m = Model()","category":"page"},{"location":"tutorial/#Store-the-model-elements-ready-for-build-by-adding-them","page":"Tutorial","title":"Store the model elements ready for build by adding them","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As in the overview explanation, each model will have a number on elements. We store all those elements in the named model, and then we can test, solve, alter, print, re-solve e.t.c.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Note\nScalar values and arrays can be used to provide values for data and parameters such as elasticities, but cannot be tracked or changed within the model and counterfactuals, so any value that needs to be updated should be added as a model Parameter.\nAfter being defined, asimmediately below, in order to access model Parameters within other model elements, they must be part of expressions (like a sentence of code). So, for referencing the value of sub_elas_x, it must be within an evaluated expression, like  \n:(1 * $sub_elas_x)\nincluding being multiplied by a scalar, or in some other equation, rather than just sub_elas_x \nThe model can be built in any order, so long as all elements referred to have been previously defined. For that reason a standard structure is: load the data, scalars, indexes; add model parameters, sectors, commodities, auxiliary variables, and consumers; add production and demand functions, and auxilliary constraint equations.\nExtra spaces after commas or opening parenthesis aren't a problem in Julia, so can we align parallel elements - for instance the elements of the 3 Parameters immediately below - to help readability.","category":"page"},{"location":"tutorial/#Add-Parameters","page":"Tutorial","title":"Add Parameters","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We'll start by defining 6 Paramters, and giving them a value. Each is just a name with a number attached, but defining them within the model as Parameters, instead of just using the numbers, or a Julia variables, allows us to update those values for future runs/solves or the model.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Adding a Parameter with the optional description\nsub_elas_x    = add!(m, Parameter(:sub_elas_x,    value=1.5, description=\"Substitution elasticity between labor and kapital in sector X\"))\n# Adding Parameters without the optional description\nsub_elas_y    = add!(m, Parameter(:sub_elas_y,    value=2.))\ntransf_elas_x = add!(m, Parameter(:transf_elas_x, value=0.))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Note\nThere is a 'functional' and macro version (begninning with @) for all model definition elements. The macro versions may lag in terms of incorporating all elements while the package is still in development. We show examples of both versions here as part of this tutorial, they are equivalent.","category":"page"},{"location":"tutorial/#The-macro-version-for-adding-Parameters","page":"Tutorial","title":"The macro version for adding Parameters","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@parameter(m, sub_elas_u,    0.5)\n@parameter(m, transf_elas_y, 0.,  description=\"Transformation Elasticity for sector Y, actually irrelevant because there's only 1 output\")\n@parameter(m, endow, value = 1.0)","category":"page"},{"location":"tutorial/#Add-Commodities","page":"Tutorial","title":"Add Commodities","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Commodities are one of the basic elements in an MPSGE model, they are produced by sectors/firms, factors used in the production of other commodities, or both. Here again, we show both the 'functional' and macro versions for adding these elements, with and without the options of a description, or a 'benchmark' price. The default benchmark price is 1. To set a different price or to articulately set it as 1, use the keyword benchmark=, and similarly, to include an optional description, use the keyword description=, as below.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"PX = add!(m, Commodity(:PX))\nPY = add!(m, Commodity(:PY, benchmark=1.))\nPU = add!(m, Commodity(:PU, description=\"The Utility Commodity\"))\n# The macro version\n@commodity(m,           PL, description=\"wage: the price of labour\")\n@commodity(m,           PK, benchmark=1.)","category":"page"},{"location":"tutorial/#Add-Sectors","page":"Tutorial","title":"Add Sectors","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Sectors use commodities (Inputs), and generate commodities (Outputs).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"X = add!(m, Sector(:X))\n@sector(m,  Y)\n@sector(m,  U, description=\"Sector U: This 'sector' uses the two produced goods to generate utility\")","category":"page"},{"location":"tutorial/#Add-a-Consumer","page":"Tutorial","title":"Add a Consumer","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For Consumers in the model the benchmark value is important. In the benchmark callibration of the model, this value will be the sum of endowments, plus the value of any taxes transferred to the consumer.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@consumer(m, RA, benchmark = 150., description=\"Representative Agent\")","category":"page"},{"location":"tutorial/#Add-Production-Functions","page":"Tutorial","title":"Add Production Functions","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we define a production function for every sector/firm. That is:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"what commodities are used by the sector and in what quantities,\nwhat commodities are produced by the sector and in what quantities,\nhow interchangeable are the inputs (substitution elasticities)\nhow interchangeable are the outputs (transformation elasticities),\nwhat taxes are paid, if any, and\nwhat price per unit of each commodity (default is 1. for all commodities as is standard the convention for CGE models)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Note\nOutputs and Inputs are within [] Arrays, even if there is only one.  Outputs must always be first.Production Functions don't need names assigned (that is, we don't have X = add!(m, Production(...)), just add!(m, Production(...))) bc they are named by the sector.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"add!(m, Production(X, :($transf_elas_x*1.), :($sub_elas_x*1.), [Output(PX, 100)], [Input(PL, 50),  Input(PK, 50)]))\n@production(m,     Y, :($transf_elas_y*1.), :($sub_elas_y*1.), [Output(PY, 50)],  [Input(PL, 20),  Input(PK, 30)])\n@production(m,     U, 0,                    :($sub_elas_u*1.), [Output(PU, 150)], [Input(PX, 100), Input(PY, 50)])","category":"page"},{"location":"tutorial/#Add-Demand-Functions","page":"Tutorial","title":"Add Demand Functions","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The Demand function defines the basic supplies that enter our modelled economy (endowments),  which come from 'consumers', and their final consumption. Final consumption is the end point of a commodity's production cycle, as the name suggests. Commodities demanded are assumed to be consumeed at that point, or at least kept, and and not used in any production in the modelled part of the economy Consumers can be households, governments, or other agents. In the benchmark callibration of a model, the total value of the consumers contributions (endowments) must equal the value of their total demands.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@demand(m, RA, 1., [Demand(PU, 150)], [Endowment(PL, :(70 * $endow)), Endowment(PK, 80.)])","category":"page"},{"location":"tutorial/#Check-the-benchmark-solution","page":"Tutorial","title":"Check the benchmark solution","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"After the model is established and saved under the model name, it is important to check that the model is mathematically balanced in the benchmark by solving with 0 iterations. This will only solve if all elements of the model are in balance, that is:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"total supply of each commodity = its total demand\nthe value of the inputs for each sector and consumer = their outputs\nthe value of all inputs in each sector = the value of all the sector's outputs.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"solve!(m, cumulative_iteration_limit=0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If the model solves with zero iterations, we know that the model and data are balanced and callibrated in the benchmark.      If not, you will get the error  Did not solve with error: CumulativeMinorIterationLimit.  ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tip: Tip\nThe Major Iteration Log from PATH will display the variable(s), preceded by \"F_\" (label) with the largest marginal value, that is the variables that have the residual solved value or inormthat is larger than the tolerance set, which can be useful for troubleshooting.   You can also run solve!(m) without the iteration limit and examine the values for all variables for more clues as to where the benchmark may be unbalanced.","category":"page"},{"location":"tutorial/#See-the-underlying-model-equations","page":"Tutorial","title":"See the underlying model equations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can print all the equations and their associated variables.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"algebraic_version(m)","category":"page"},{"location":"tutorial/#Run-Counterfactuals","page":"Tutorial","title":"Run Counterfactuals","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once the benchmark is established, update variable values and/or parameters, fix or unfix variables etc. and see the solution as in the simulated counterfactual scenario.","category":"page"},{"location":"tutorial/#Example:-Increase-labor-endowment-by-10%","page":"Tutorial","title":"Example: Increase labor endowment by 10%","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We used the paramater we called endow, initially set at a value of 1.0, to enable us to alter the total amount/value of the endowments of labour and see its effect on our toy economy. By setting the value of endow as 10% higher, at 1.1, we alter the model to increase the amount of labour in this economy by 10%.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"set_value(endow, 1.1)","category":"page"},{"location":"tutorial/#And-set-the-consumer-RA-as-the-numeraire","page":"Tutorial","title":"And set the consumer RA as the numeraire","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Because all the changes in our results are relative, it is usually useful to select a variable to serve as the 'numeraire', that is, a variable whose value is fixed and set such that all the other changes can be interpreted in relative terms to that variable.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"set_fixed!(RA, true)\nsolve!(m)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Or we can look at the results relative to the price of the commodity PX.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"set_fixed!(RA, false)\nset_fixed!(PX, true)\nsolve!(m)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Or we can look at the results relative to wages, the price of labour in our toy economy.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"set_fixed!(PX, false)\nset_fixed!(PL, true)\nsolve!(m)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Or here we test the impact of different set of assumptions about how interchangeable kapital and labour are in the X and Y sectors.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Re-running with non-1 elasticities of substitution, non-Cobb-Douglas forms for production in the cost function\nset_value(sub_elas_x, 0.5)\nset_value(sub_elas_y, 0.6)\nset_fixed!(RA, true)\nsolve!(m)\n\nset_fixed!(PX, true)\nset_fixed!(RA, false)\nsolve!(m)\n\nset_fixed!(PX, false)\nset_fixed!(PL, true)\nsolve!(m)","category":"page"}]
}
